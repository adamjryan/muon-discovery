// Targeted by JavaCPP version 1.3.2: DO NOT EDIT THIS FILE

package io.muoncore.discovery;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class DiscoveryJni extends io.muoncore.javacpp.DiscoveryJavaCppSpec {
    static { Loader.load(); }

@Name("std::vector<std::string>") public static class StringVector extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public StringVector(Pointer p) { super(p); }
    public StringVector(BytePointer ... array) { this(array.length); put(array); }
    public StringVector(String ... array) { this(array.length); put(array); }
    public StringVector()       { allocate();  }
    public StringVector(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef StringVector put(@ByRef StringVector x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @StdString BytePointer get(@Cast("size_t") long i);
    public native StringVector put(@Cast("size_t") long i, BytePointer value);
    @ValueSetter @Index public native StringVector put(@Cast("size_t") long i, @StdString String value);

    public StringVector put(BytePointer ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }

    public StringVector put(String ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<URI>") public static class URIVector extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public URIVector(Pointer p) { super(p); }
    public URIVector(URI ... array) { this(array.length); put(array); }
    public URIVector()       { allocate();  }
    public URIVector(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef URIVector put(@ByRef URIVector x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native @ByRef URI get(@Cast("size_t") long i);
    public native URIVector put(@Cast("size_t") long i, URI value);

    public URIVector put(URI ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<ServiceDescriptor*>") public static class ServiceDescriptorPointerVector extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ServiceDescriptorPointerVector(Pointer p) { super(p); }
    public ServiceDescriptorPointerVector(ServiceDescriptor ... array) { this(array.length); put(array); }
    public ServiceDescriptorPointerVector()       { allocate();  }
    public ServiceDescriptorPointerVector(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef ServiceDescriptorPointerVector put(@ByRef ServiceDescriptorPointerVector x);

    public native long size();
    public native void resize(@Cast("size_t") long n);

    @Index public native ServiceDescriptor get(@Cast("size_t") long i);
    public native ServiceDescriptorPointerVector put(@Cast("size_t") long i, ServiceDescriptor value);

    public ServiceDescriptorPointerVector put(ServiceDescriptor ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

// Parsed from io/muoncore/discovery/URI.h

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/* 
 * File:   URI.h
 * Author: adam
 *
 * Created on 22 January 2017, 13:03
 */

// #ifndef URI_H
// #define URI_H

public static class URI extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public URI(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public URI(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public URI position(long position) {
        return (URI)super.position(position);
    }

    public URI() { super((Pointer)null); allocate(); }
    private native void allocate();
}

// #endif /* URI_H */

// Parsed from io/muoncore/discovery/ServiceDescriptor.h

/* 
 * File:   ServiceDescriptor.h
 * Author: adam
 *
 * Created on 22 January 2017, 12:58
 */

// #ifndef SERVICEDESCRIPTOR_H
// #define SERVICEDESCRIPTOR_H

// #include <string>
// #include <vector>
// #include "io/muoncore/discovery/ServiceDescriptorSer.h"
// #include "URI.h"

@NoOffset public static class ServiceDescriptor extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ServiceDescriptor(Pointer p) { super(p); }

    public ServiceDescriptor( @StdString BytePointer identifier ) { super((Pointer)null); allocate(identifier); }
    private native void allocate( @StdString BytePointer identifier );
    public ServiceDescriptor( @StdString String identifier ) { super((Pointer)null); allocate(identifier); }
    private native void allocate( @StdString String identifier );
    
    public ServiceDescriptor( @StdString BytePointer identifier, StringVector tags, StringVector codecs, URIVector connectionUris, StringVector capabilities ) { super((Pointer)null); allocate(identifier, tags, codecs, connectionUris, capabilities); }
    private native void allocate( @StdString BytePointer identifier, StringVector tags, StringVector codecs, URIVector connectionUris, StringVector capabilities );
    public ServiceDescriptor( @StdString String identifier, StringVector tags, StringVector codecs, URIVector connectionUris, StringVector capabilities ) { super((Pointer)null); allocate(identifier, tags, codecs, connectionUris, capabilities); }
    private native void allocate( @StdString String identifier, StringVector tags, StringVector codecs, URIVector connectionUris, StringVector capabilities );

    public native @Cast("bool") boolean equals( ServiceDescriptor object );

//    size_t hashCode()
    public native int hashCode();

    public native @StdString BytePointer getIdentifier();

    public native StringVector getTags();

    public native StringVector getCodecs();

    public native URIVector getConnectionUris();

    public native StringVector getCapabilities();
}

// #endif /* SERVICEDESCRIPTOR_H */

// Parsed from io/muoncore/discovery/DiscoveryOnReady.h

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/* 
 * File:   DiscoveryOnReady.h
 * Author: adam
 *
 * Created on 22 January 2017, 13:04
 */

// #ifndef DISCOVERYONREADY_H
// #define DISCOVERYONREADY_H

public static class DiscoveryOnReady extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public DiscoveryOnReady(Pointer p) { super(p); }

    public native void call();
}

// #endif /* DISCOVERYONREADY_H */

// Parsed from io/muoncore/discovery/Discovery.h

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/* 
 * File:   Discovery.h
 * Author: adam
 *
 * Created on 22 January 2017, 13:02
 */

// #ifndef DISCOVERY_H
// #define DISCOVERY_H

// #include <vector>
// #include "DiscoveryOnReady.h"
// #include "io/muoncore/discovery/ServiceDescriptor.h"

public static class Discovery extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Discovery(Pointer p) { super(p); }

    public native void setEnabled( @Cast("bool") boolean enabled );
    public native void onReady( DiscoveryOnReady discoveryOnReady );
    public native void advertiseLocalService( ServiceDescriptor serviceDescriptor );
    public native void getKnownServices( ServiceDescriptorPointerVector arg0 );
}

// #endif /* DISCOVERY_H */

// Parsed from io/muoncore/discovery/ServiceDescriptorServer.h

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/* 
 * File:   ServiceDescriptorServer.h
 * Author: adam
 *
 * Created on 22 January 2017, 12:57
 */

// #ifndef SERVICEDESCRIPTORSERVER_H
// #define SERVICEDESCRIPTORSERVER_H

// #include <vector>
// #include <thread>
// #include <mutex>
// #include <condition_variable>
// #include <sys/socket.h>
// #include <netinet/in.h>
// #include <arpa/inet.h>
// #include "io/muoncore/discovery/ServiceDescriptor.h"

@NoOffset public static class ServiceDescriptorServer extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ServiceDescriptorServer(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public ServiceDescriptorServer(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public ServiceDescriptorServer position(long position) {
        return (ServiceDescriptorServer)super.position(position);
    }

    /** enum ServiceDescriptorServer::MessageType */
    public static final int
        SERVICE_DESCRIPTOR_REQUEST = 0,
        SERVICE_DESCRIPTOR_RESPONSE = 1,
        SERVICE_STARTED = 2,
        SERVICE_STOPPED = 3;
    @MemberGetter public static native @Cast("const char*") BytePointer MULTICAST_ADDRESS();
    @MemberGetter public static native int PORT();
    public static final int PORT = PORT();
    @MemberGetter public static native long MAX_TRANSMIT_INTERVAL();
    public static final long MAX_TRANSMIT_INTERVAL = MAX_TRANSMIT_INTERVAL();
    public static native int newUdpMulticastSocket( @Cast("const char*") BytePointer ipAddress, @Cast("uint16_t") short port );
    public static native int newUdpMulticastSocket( String ipAddress, @Cast("uint16_t") short port );

    public ServiceDescriptorServer() { super((Pointer)null); allocate(); }
    private native void allocate();

    public native void setServiceDescriptor( ServiceDescriptor serviceDescriptor );

    public native void setEnabled( @Cast("bool") boolean enabled );
}

// #endif /* SERVICEDESCRIPTORSERVER_H */

// Parsed from io/muoncore/discovery/ServiceDescriptorClient.h

//
// Created by adam on 19/05/17.
//

// #ifndef MUON_DISCOVERY_SERVICEDESCRIPTORCLIENT_H
// #define MUON_DISCOVERY_SERVICEDESCRIPTORCLIENT_H

// #include <thread>
// #include <map>
// #include "io/muoncore/discovery/ServiceDescriptorServer.h"

@NoOffset public static class ServiceDescriptorClient extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ServiceDescriptorClient(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public ServiceDescriptorClient(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public ServiceDescriptorClient position(long position) {
        return (ServiceDescriptorClient)super.position(position);
    }

    @NoOffset public static class ServiceCache extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ServiceCache(Pointer p) { super(p); }
    
        public native void getServices( ServiceDescriptorPointerVector serviceDescriptors );
    }
    public ServiceDescriptorClient() { super((Pointer)null); allocate(); }
    private native void allocate();

    public native void setEnabled( @Cast("bool") boolean enabled );

    public native ServiceCache getServiceCache();
}

// #endif //MUON_DISCOVERY_SERVICEDESCRIPTORCLIENT_H

// Parsed from io/muoncore/discovery/MulticastDiscovery.h

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/* 
 * File:   MulticastDiscovery.h
 * Author: adam
 *
 * Created on 22 January 2017, 13:11
 */

// #ifndef MULTICASTDISCOVERY_H
// #define MULTICASTDISCOVERY_H

// #include "Discovery.h"
// #include "ServiceDescriptorServer.h"
// #include "ServiceDescriptorClient.h"
// #include <string>
// #include <vector>

@NoOffset public static class MulticastDiscovery extends Discovery {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public MulticastDiscovery(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public MulticastDiscovery(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public MulticastDiscovery position(long position) {
        return (MulticastDiscovery)super.position(position);
    }

    public MulticastDiscovery() { super((Pointer)null); allocate(); }
    private native void allocate();

    public native void setEnabled( @Cast("bool") boolean enabled );

    public native void onReady( DiscoveryOnReady discoveryOnReady );

    public native void advertiseLocalService( ServiceDescriptor serviceDescriptor );
    
    public native void getKnownServices( ServiceDescriptorPointerVector serviceDescriptors );
}

// #endif /* MULTICASTDISCOVERY_H */

}
